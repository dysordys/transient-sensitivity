# R script to explore whether and when low forb densities imply high sensitivity
# against perturbing the death rate of the forb in the seed bank, in the annual
# plant model


# Load packages -----------------------------------------------------------------------

library(tidyverse) # For efficient data manipulation and plotting
library(deSolve) # Here used for solving difference (instead of differential) equations



# Define functions --------------------------------------------------------------------

# Generate sequence of parameter values through time which take on different values
# in good vs. bad years
# Input:
# - b: Value of parameter in bad years
# - g: Value of parameter in good years
# - year: Vector of some sequence of 0s (bad years) and 1s (good years)
# Output:
# - A numeric vector like year, but with the 0s replaced with a and the 1s with g
env <- function(b, g, year) b * (1 - year) + g*year


# The annual plant model equations for two species, projecting the dynamics from
# one year to the next (Eq. 14 in the manuscript, but on the log scale)
# Input:
# - time: The year (time point) at which the equations should be evaluated
# - state: Vector of two values: the log density of the forb and that of the grass
# - p: List of model parameters; see the function param_list for its members
# Output:
# - The vector of log densities in the next year, coerced into a list (needed so that
#   one can use the "iteration" method of the deSolve package for solving the equations)
eqs <- function(time, state, p) {
  g <- env(c(p$gFb, p$gGb), c(p$gFg, p$gGg), p$year[time])
  l <- env(c(p$lambdaFb, p$lambdaGb), c(p$lambdaFg, p$lambdaGg), p$year[time])
  d <- c(p$dF, p$dG)
  alpha <- c(p$alpha, 1)
  list(state + log((1-g)*(1-d)+(l*g)/(1+alpha*sum(g*exp(state)/alpha))))
}


# Solve the transient sensitivity equation when perturbing the death rate of the forb
# in the seed bank (Eq. 6 in the manuscript, with a(t) and z(t) given by Eqs. 18-19)
# Input:
# - time: The year (time point) at which the equations should be evaluated
# - state: Vector of two values: the log density of the forb and that of the grass
# - p: List of model parameters; see the function param_list for its members
# - sol0: A data frame with the solution of the unperturbed model, in the form
#   generated by applying the function frame_results
# Output:
# - The vector of sensitivities in the next year, coerced into a list (needed so that
#   one can use the "iteration" method of the deSolve package for solving the equations)
sensitivity <- function(time, state, p, sol0) {
  g <- env(c(p$gFb, p$gGb), c(p$gFg, p$gGg), p$year[time])
  l <- env(c(p$lambdaFb, p$lambdaGb), c(p$lambdaFg, p$lambdaGg), p$year[time])
  d <- c(p$dF, p$dG)
  alpha <- c(p$alpha, 1)
  n <- exp(c(sol0$forb[time], sol0$grass[time]))
  reg <- sum(g*n/alpha)
  a <- (-l*g*alpha/((1-d)*(1-g)*(1+alpha*reg)^2 + l*g*(1+alpha*reg))) %o% (g*n/alpha)
  z <- ((g-1)/((1-d)*(1-g)+l*g/(1+alpha*reg))) * c(1, 0)
  list(as.numeric((diag(2) + a) %*% state) + z)
}


# Take a deSolve object generated by deSolve::ode, and convert it to a tibble
# Input:
# - sol: The solution to a dynamical system, generated by deSolve::ode
# Output:
# - A tibble with three columns: time, forb, and grass (the latter two
#   measuring the log densities)
frame_results <- function(sol) {
  sol |>
    as.data.frame() |>
    as_tibble() |>
    rename(forb = `1`, grass = `2`)
}


# Create a list of parameter values, with the sequence of good and bad years
# explicitly passed in as a vector
# Input:
# - year: Vector of some sequence of 0s (bad years) and 1s (good years)
# Output:
# - A list with all the model parameters (see below)
param_list <- function(year) {
  list(
    dF = 0.1,      # Forb death rate in seed bank
    dG = 0.7,      # Grass death rate in seed bank
    lambdaFb = 5,  # Number of forb seeds/individual in a bad year
    lambdaFg = 30, # Number of forb seeds/individual in a good year
    lambdaGb = 5,  # Number of grass seeds/individual in a bad year
    lambdaGg = 30, # Number of grass seeds/individual in a good year
    gFb = 0.1,     # Fraction of forb seeds germinating in a bad year
    gFg = 0.7,     # Fraction of forb seeds germinating in a good year
    gGb = 0.9,     # Fraction of grass seeds germinating in a bad year
    gGg = 0.9,     # Fraction of grass seeds germinating in a good year
    alpha = 2,     # Reciprocal interspecific competition coefficient
    year = year    # Sequence of bad (0) & good (1) years, as a numeric vector
  )
}



# Run simulations ---------------------------------------------------------------------

set.seed(76543) # Set random seed (for reproducibility)
tmax = 100 # Maximum number of time steps (years) for iterating the equations

sol <- # Compile large table of replicate model simulations
  # Fully factorial combination of:
  crossing(replicate = 1:200,          # 200 replicates per initial condition
           ic_forb = c(-3,-1,1,3),     # Initial log density of the forb
           ic_grass = c(-3,-1,1,3)) |> # Initial log density of the grass
  # Index each combination with unique id:
  rowid_to_column("simulation") |>
  # Create column with initial conditions (length-2 vectors):
  mutate(ic = map2(ic_forb, ic_grass, \(f, g) c(f, g))) |>
  # For each combination, generate a random sequence of good and bad years:
  mutate(year = map(simulation, \(x) {
    sample(x = c(0, 1), size = tmax, replace = TRUE, prob = c(0.5, 0.5))
  })) |>
  # For each combination, generate full list of parameters:
  mutate(pars = map(year, param_list)) |>
  # Solve each of the 200*4*4 model setups:
  mutate(dens = map2(ic, pars, \(ic, pars) {
    ode(func = eqs, y = ic, times = 1:tmax, parms = pars, method = "iteration") |>
      frame_results()
  })) |>
  # With the solution at hand, solve the sensitivity equations as well:
  mutate(sens = map2(pars, dens, \(pars, dens) {
    ode(func = sensitivity, y = rep(0, 2), times = 1:tmax, parms = pars,
        method = "iteration", sol0 = dens) |>
      frame_results() |>
      select(-time)
  })) |>
  # Unpack data from sub-tibbles and clean up:
  unnest(c(dens, sens), names_sep = "_") |>
  rename(time = dens_time)



# Display results ---------------------------------------------------------------------

sol |>
  # For each parameterization, calculate correlation between density and sensitivity,
  # for both forb and grass:
  group_by(simulation, ic_forb, ic_grass) |>
  summarise(corr_forb = cor(dens_forb, sens_forb),
            corr_grass = cor(dens_grass, sens_grass)) |>
  ungroup() |>
  # Tidy up the results:
  pivot_longer(cols = contains("corr_"), values_to = "correlation coefficient") |>
  mutate(name = str_remove(name, "corr_")) |>
  # Add correlation coefficient from the example of the main text by hand:
  mutate(obs = ifelse(simulation == 16 & name == "forb", 0.537, NA)) |>
  # Change column names (to show better on plot):
  rename(`log initial forb` = ic_forb, `log initial grass` = ic_grass) |>
  # Create plot:
  ggplot(aes(x = name, y = `correlation coefficient`, colour = name, fill = name)) +
  geom_boxplot(alpha = 0.2) +
  geom_errorbar(aes(ymin = obs, ymax = obs), colour = "gray36") +
  facet_grid(`log initial grass` ~ `log initial forb`,
             labeller = \(x) label_both(x, sep = " = ")) +
  scale_colour_manual(values = c("#0072B2", "#E69F00"), guide = "none") +
  scale_fill_manual(values = c("#0072B2", "#E69F00"), guide = "none") +
  theme_bw() +
  theme(panel.grid = element_blank(), axis.title.x = element_blank())

# Display any one particular parameterization from the main table of results:
sol |>
  # Pick one simulation:
  filter(simulation == 976) |> # Or any other value between 1 and 200*4*4 = 3200
  # Tidy up the data:
  select(time, contains("s_")) |>
  pivot_longer(cols = contains("_")) |>
  separate_wider_delim(cols = name, delim = "_", names = c("type", "species")) |>
  mutate(type = ifelse(type == "dens", "log density", "sensitivity")) |>
  # Plot results:
  ggplot(aes(x = time, y = value, colour = species)) +
  geom_line() +
  facet_grid(type ~ species, scales = "free_y", switch = "y") +
  scale_colour_manual(values = c("#0072B2", "#E69F00")) +
  theme_bw() +
  theme(panel.grid = element_blank(), axis.title.y = element_blank())
